﻿<img width="100%" src="https://capsule-render.vercel.app/api?type=waving&color=9df2ea&animation=fadeIn&height=120&section=header"/>

## Introducción:
 
Imagina que estás disfrutando de un viaje en el tiempo a la antigua corte del emperador romano Julio César. Estás sentado a la mesa de su consejo, rodeado de matemáticos y astrónomos de renombre, cuando el emperador se vuelve hacia ti con una mirada expectante. "Amigo mío", dice con voz grave, "necesitamos resolver un gran enigma del calendario. ¿Cómo determinamos cuáles años serán bisiestos?"

Sientes el peso de la historia sobre tus hombros mientras los ojos de todos se fijan en ti. No puedes defraudar al gran César. Sabes que los años bisiestos son necesarios para mantener el calendario alineado con las estaciones, evitando que la primavera llegue en diciembre y las navidades en verano. Tomas un respiro profundo y piensas en las reglas que conoces: ¿Es el año divisible por 4? ¡Quizá sea bisiesto! ¿Es divisible por 100 pero no por 400? ¡No tan rápido, no es bisiesto!

La sala está en silencio, a la espera de tu respuesta. Sabes que la reputación del consejo de César está en juego. Por suerte, tienes tus habilidades de programación listas para entrar en acción. ¡Es hora de escribir un método que compruebe si un año es bisiesto o no!

¡A programar! Porque no quieres ser la persona que sugirió un año bisiesto incorrecto y desató el caos en la antigua Roma.

## Tener en cuenta:

- Escribir un test de fallo para un comportamiento simple.
- Implementar la menor cantidad de código necesaria para que el test pase.
- A medida que añades más tests, refactorizar para hacer el código más genérico y apropiado.

## Instrucciones:

Implementa un método que compruebe si un año es bisiesto.

Deben cumplirse todas las siguientes normas:

- Un año no es bisiesto si no es divisible por 4
- Un año es bisiesto si es divisible por 400
- Un año no es bisiesto si es divisible por 100 pero no por 400

Ejemplos:

- 1997 no es bisiesto (no es divisible por 4)
- 1996 es bisiesto (divisible por 4)
- 1600 es bisiesto (divisible por 400)
- 1800 no es bisiesto (divisible por 4, divisible por 100, NO divisible por 400).

El método debe devolver 'true' si un año es bisiesto, y 'false' si no lo es.

## Créditos

[Kata original](https://www.codurance.com/es/katas/leap-year)


<img src="https://raw.githubusercontent.com/matfantinel/matfantinel/master/waves.svg" width="100%" height="100">